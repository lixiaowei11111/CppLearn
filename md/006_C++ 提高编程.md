# C++ 提高编程

## 1. 模板 (Cpp 泛型编程)

## 1.1 模板的概念

+ 模板就是建立**通用的模具**，大大**提高复用性**
+ 生活中模板 
  + PPT模板
  + 一寸照片模板

## 1.2 函数模板

+ C++另一种编程思想称为 ==泛型编程== ，主要利用的技术就是模板


* C++提供两种模板机制:**函数模板**和**类模板** 

#### 1.2.1 函数模板语法

函数模板作用：

建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个**虚拟的类型**来代表。



**语法：** 

```C++
template<typename T>
函数声明或定义
```

**解释：**

template  ---  声明创建模板

typename  --- 表面其后面的符号是一种数据类型，**可以用class代替**

T    ---   通用的数据类型，名称可以替换，通常为大写字母



**示例：**

```c++
#include <iostream>

using std::cout;
using std::endl;
using std::string;

// 不适用泛型编程,交换 整数和 浮点数

// 1. 交换整数
void swapInt(int& a, int& b) {
	int temp = a;
	a = b;
	b = temp;
}

//2. 交换浮点数
void swapDouble(double& a, double& b) {
	double temp = a;
	a = b;
	b = temp;
}

// 使用
void test01() {
	int a = 10, b = 20;
	swapInt(a, b);
	cout << "a:" << a << ";" << "b:"<< b << endl; // a : 20;b:10
	double c = 0.13, d = 0.99;
	swapDouble(c, d);
	cout << "c:" << c << ";" << "d:" << d << endl;//c:0.99;d:0.13
}
// 使用上面两个函数定义显得代码过于臃肿,不利于维护, 利用cpp 泛型编程的思想 类似于typescript中的泛型
template<typename T>
void mySwap(T& a, T& b) {
	T temp = a;
	a = b;
	b = temp;
}

void test02() {
	// 使用泛型定义的函数的两种方法

	// 1. 编译器自动类型推导
	int a = 200, b = 88;
	mySwap(a, b);
	cout << "a:" << a << ";" << "b:" << b << endl; //a : 88; b:200

	// 2. 手动标明指定类型
	double c = 3.33, d = 9.9999;
	mySwap<double>(c, d);
	cout << "c:" << c << ";" << "d:" << d << endl;// c : 9.9999; d:3.33
}

int main() {
	test01();
	test02();
	system("pause");
	return 0;
}
```

总结：

* 函数模板利用关键字 template
* 使用函数模板有两种方式：自动类型推导、显示指定类型
* 模板的目的是为了提高复用性，将类型参数化

#### 1.2.2 函数模板注意事项

注意事项：

* 自动类型推导，必须推导出一致的数据类型T,才可以使用


* 模板必须要确定出T的数据类型，才可以使用

**示例**

```c++
//template<class T> // 定义泛型关键字 可以用 typename 也可以用 class
// 一般可以定义类class时 使用 class ,定义函数时使用 typename
// 或者 无论函数 还是 类 ,都用class 关键字
// 使用泛型时,要注意的两点

//1. 自动类型推导，必须推导出一致的数据类型T,才可以使用

template<typename T>
void mySwap(T& a, T& b) {
	T temp = a;
	a = b;
	b = temp;
}
void test01() {
	int a = 10;
	string b = "aa";
	char char1[] = "1311331";
	//mySwap(a, b);// error 没有与参数类型匹配的函数模板
	//mySwap(b, char1);// error 没有与参数类型匹配的函数模板
}

// 2. 模板必须要确定出T的数据类型，才可以使用
template<class T>
void func() {
	cout << "运行func函数" << endl;
}

void test02() {
	//func();//error 函数必须要确定出T的数据类型 才可以使用
	func<string>();// 运行func函数
}

int main() {
	test01();
	test02();
	system("pause");
	return 0;
}
```



#### 1.2.3 函数模板案例

案例描述：

* 利用函数模板封装一个排序的函数，可以对**不同数据类型数组**进行排序
* 排序规则从大到小，排序算法为**选择排序**
* 分别利用**char数组**和**int数组**进行测试



示例：

```c++
//	* 利用函数模板封装一个排序的函数，可以对**不同数据类型数组**进行排序
//	*排序规则从大到小，排序算法为** 选择排序**
//	* 分别利用** char数组** 和** int数组** 进行测试

// 交换泛型函数
template<class T>
void mySwap(T &a, T &b) {
	T temp = a;
	a = b;
	b = temp;
};
 //选择排序, 从大到小 依次排序
template<class T>
void myArrSort(T arr[],int len) {

	// 选择排序算法实现
	for (int i = 0; i < len; i++) {
		// 假设最大数下表为 i
		int max = i;
		for (int j = i + 1; j < len; j++) {
			// 逐个比较,直到找到比max还大的数
			if (arr[max] < arr[j]) {
				max = j;// 保存较大的数的下标
			}
		}
		if (max != i) {// 如果 max被改了, 就交换两个数的位置
			mySwap(arr[max], arr[i]);// 少了个分号为什么不提示
		}
	}
};
// 逐个打印
template<class T>
void printfArr(T arr[],int len) {
	//int len = sizeof(arr) / sizeof(T);
	for (int i = 0; i < len; i++) {
		cout << arr[i] << " ";
	}
	cout << endl;
}


void test01() {
	// char数组
	char a[] = "abcdefg";
	int len = sizeof(a) / sizeof(char);
	myArrSort(a, len);
	printfArr(a,len);
}


int main() {
	test01();
	system("pause");
	return 0;
}
```



**普通函数与函数模板区别：**

* 普通函数调用时可以发生自动类型转换（隐式类型转换）
* 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换
* 如果利用显示指定类型的方式，可以发生隐式类型转换



**示例：**

```c++
// 普通函数和函数模板的区别
// 1. 普通函数自动调用 隐式转换
// 2. 模板函数,
// 2.1 模板函数中利用自动类型推导, 则不会发生隐式转换
// 2.2 模板函数显式的制定类型,可以发生隐式转换

// 1. 普通函数
int add(int a,int b){
    return a+b;
}
// 2. 模板函数,自动类型推导
template<typename T>
T autoTypeAdd(T a,T b){
    return  a+b;
}

void test01(){
    int a=10;
    int b=20;
    char c='c';
    cout<<add(a,c)<<endl;// 109
    cout<<c<<int(c)<<endl;
    // 不采用引用,则在函数参数给其赋值时 b=int(c)=99,自动进行隐式转换,用引用则不行
    // cout<<autoTypeAdd(a,c);// error 自动类型推导时,模板函数不进行隐式转换
    cout<<autoTypeAdd<int>(a,c);//109 显式制定类型为int, 则和普通函数add一样
}

int main() {
    test01();
    system("pause");
    return 0;
}
```



#### 1.2.5 普通函数与函数模板的调用规则



调用规则如下：

1. 如果函数模板和普通函数都可以实现，优先调用普通函数
   1. **注意 如果同名普通函数只有声明,没有定义,则编译器还是会调用 同名普通函数,并且会报错该函数未定义**

2. 可以通过空模板参数列表来强制调用函数模板
3. 函数模板也可以发生重载
4. 如果函数模板可以产生更好的匹配,优先调用函数模板





**示例：**

```c++
// 函数模板 和 同名普通函数的调用规则
// 1.如果函数模板和普通函数都可以调用,则优先调用 普通函数
    // 注意 如果同名普通函数只有声明,没有定义,则编译器还是会调用 同名普通函数,并且会报错该函数未定义
// 2. 强制调用模板函数: 通过空模板参数列表来调用<>
// 3. 函数模板也可以发生重载
// 4. 如果函数模板可以产生更好的匹配,优先调用函数模板

template<class T>
// 同名模板函数
void myPrint(T a,T b){
    cout<<"模板函数调用"<<endl;
};


void myPrint(int a,int b){
    cout<<"普通函数调用"<<endl;
}

// 函数模板重载
template<class T>
void myPrint(T a,T b,T c){
    cout<<"调用重载函数模板"<<endl;
};


void test01(){
    int a=10;
    int b=20;
    int c=30;
    myPrint(a,b);// 普通同名函数调用
    myPrint<>(a,b);// 模板函数调用 使用空模板参数列表来强制调用 模板函数
    myPrint(a,b,c);// 调用重载函数模板 函数模板发生的重载

    char d='d';
    char e='e';
    myPrint(d,e);//模板函数调用 普通同名函数可以发生隐式转换, 但编译器会优先调用 模板函数
}


int main() {
    test01();
    system("pause");
    return 0;
}
```

总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板



#### 1.2.6 模板的局限性

**局限性：**

* 模板的通用性并不是万能的



**例如：**

```C++
	template<class T>
	void f(T a, T b)
	{ 
    	a = b;
    }
```

在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了



再例如：

```C++
	template<class T>
	void f(T a, T b)
	{ 
    	if(a > b) { ... }
    }
```

在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行



因此C++为了解决这种问题，提供模板的重载，可以为这些**特定的类型**提供**具体化的模板**



**示例：**

```c++
// 比较两个数是否相等的的模板函数
// 这种处理不了复杂一点的数据 比如 数组 和 类
template<typename T>
bool myCompare(T &a,T &b){
    return  a==b;
};

class Person{
public:
    Person(string name,int age){
        this->m_Name=name;
        this->m_Age=age;
    }
    string m_Name;
    int m_Age;
};
// 具体化模板会优先调用
template<>bool myCompare(Person &a,Person &b){
    if(a.m_Age == b.m_Age&&a.m_Name == b.m_Name){
        return true;
    }else{
        return false;
    }
};

void test01(){
    int a=100;
    int b=90;
    cout<<(myCompare(a,b)?"a==b":"a!=b")<<endl;
     Person p1= Person("张三",22);
     Person p2= Person("张三",22);
    cout<<(myCompare(p1,p2)?"a==b":"a!=b")<<endl;// a==b 比较特殊变量类型的大小需要具体化模板
};

int main() {
    test01();
    system("pause");
    return 0;
}
```



## 1.3 类模板

#### 1.3.1 类模板语法

类模板作用：

* 建立一个通用类，类中的成员 数据类型可以不具体制定，用一个**虚拟的类型**来代表。



**语法：** 

```c++
template<typename T>
类
```

**解释：**

template  ---  声明创建模板

typename  --- 表面其后面的符号是一种数据类型，可以用class代替

T    ---   通用的数据类型，名称可以替换，通常为大写字母



**示例：**

```c++
// class template 基础语法
template<typename T,class K>
class Person{
public:
    T m_Name;
    K m_Age;
    Person(T name,K age){
        // has params constructor function
        this->m_Name=name;
        this->m_Age=age;
    }
    void showPersonInfo(){
        cout<<"name:"<<this->m_Name<<endl;
        cout<<"age:"<<this->m_Age<<endl;
    };


};

void test01(){
    Person<string,int>p1("张三",23);
    p1.showPersonInfo();
};

int main() {
    test01();
    system("pause");
    return 0;
}
```



#### 1.3.2 类模板与函数模板区别



类模板与函数模板区别主要有两点：

1. 类模板没有自动类型推导的使用方式
2. 类模板在模板参数列表中可以有默认参数



**示例：**

```c++
// 类模板 和 函数模板的两点区别
// 1. 类模板不能进行自动类型推导
// 2. 类模板在模板参数列表中可以有默认参数

template<typename T,class K>
class Person{
public:
    Person(T name,K age){
        this->m_Name=name;
        this->m_Age=age;
    };

    T m_Name;
    K m_Age;
};

// 类模板在模板参数列表中可以有默认值 <>里面的就是模板函数中的参数列表
template<class T=string,class K = int>
class Animal{
public:
    Animal(T name,K age){
        this->m_Name=name;
        this->m_Age=age;
    };
    T m_Name;
    K m_Age;
};

void test01(){
//    Person p1('张三',12);//Error 类模板 不能像函数模板一样进行自动类型推导, 因为函数模板的类型推导其实是类似于强制类型转换
    Person<string,int>p1("张三",12);
    // 默认参数列表的类模板
   Animal<>a1("张三",23);
}
int main() {
    test01();
    system("pause");
    return 0;
}
```



#### 1.3.3 类模板中成员函数创建时机



类模板中成员函数和普通类中成员函数创建时机是有区别的：

* 普通类中的成员函数一开始就可以创建
* 类模板中的成员函数在调用时才创建





**示例：**

```c++
// 普通类的 成员函数,会在 类初始化时,就创建
// 类模板中的成员函数,会在调用时才会创建
class Person{
public:
    void showPerson(){
        cout<<"showPerson func "<<endl;
    };
};

class Animal{
    void showAnimal(){
        cout<<"showAnimal func "<<endl;
    };
};

template<typename T>
class Execute{
public:
    T obj;

    void func1(){
        obj.showPerson();
    };
    void func2(){
        obj.showAnimal();
    };
};
void test01(){
    Execute<Person> e;
    e.func1();// showPerson func
    //e.func2();// error: 'class Person' has no member named 'showAnimal'
}

int main() {
    test01();
    system("pause");
    return 0;
}
```



#### 1.3.4 类模板对象做函数参数

学习目标：

* 类模板实例化出的对象，向函数传参的方式

* **typeid**关键字的使用

  * 不同编译器中不同的结果

  * gcc 默认输出为 可能为单个字母,**完整输出要引入头文件abi**,如下

    ```c++
    #include <cxxabi.h>// 引入
    
    //使用 abi中的 __cxa_demngle 函数
    abi::__cxa_demangle(typeid(T1).name(),0,0,0))
    ```

    




一共有三种传入方式：

1. 指定传入的类型   --- 直接显示对象的数据类型
2. 参数模板化           --- 将对象中的参数变为模板进行传递
3. 整个类模板化       --- 将这个对象类型 模板化进行传递





**示例：**

```c++
#include <iostream>
#include <cxxabi.h>
using std::cout;
using std::endl;
using std::string;

// 类模板 实例化出的对象, 作为函数参数的三种形式
/**
 *1. 指定传入的类型  --- 直接显示对象的数据类型
 *2. 参数模板化     --- 将对象中的参数变为模板进行传递
 *3. 整个类模板化   --- 将这个对象类型 模板化进行传递
 */

template<typename T,typename K=int>
class Person{
public:
    T m_Name;
    K m_Age;
    Person(T name,K age){
        this->m_Name=name;
        this->m_Age=age;
    };
    void showPersonInfo(){
        cout<<"name: "<<this->m_Name<<endl;
        cout<<"age: "<<this->m_Age<<endl;
    };

};
// 1. 指定传入的类型   --- 直接显示对象的数据类型
void showInfoA(Person<string ,int> p){
    p.showPersonInfo();
};
void test01(){
    Person<string>p("张三",18);
    showInfoA(p);
};

// 2. 参数模板化     --- 将对象中的参数变为模板进行传递
template<typename T1=string,typename T2=int>
void showInfoB(Person<T1 ,T2> p){
    p.showPersonInfo();
    cout<<"T type is:"<<(abi::__cxa_demangle(typeid(T1).name(),0,0,0))<<endl;
    //  std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >
    cout<<"K type is:"<<(abi::__cxa_demangle(typeid(T2).name(),0,0,0))<<endl;//int
};

void test02(){
    Person<string>p("张三",18);
    showInfoB(p);
}
// 3. 整个类模板化   --- 将这个对象类型 模板化进行传递
template <class T>
void showInfoC(T& p){
    p.showPersonInfo();
    cout<<"T type is : "<<(abi::__cxa_demangle(typeid(T).name(),0,0,0))<<endl;
    // Person<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>
};

void test03(){
    Person<string>p("王五",29);
    showInfoC(p);
}

int main() {
    test01();
    test02();
    test03();
    system("pause");
    return 0;
}
```

总结：

* 通过类模板创建的对象，可以有三种方式向函数中进行传参
* 使用比较广泛是第一种：指定传入的类型


#### 1.3.5 类模板与继承



当类模板碰到继承时，需要注意一下几点：

* 当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型
* 如果不指定，编译器无法给子类分配内存
* 如果想灵活指定出父类中T的类型，子类也需变为类模板



**示例：**

```c++
#include <iostream>
#include <cxxabi.h>

using std::cout;
using std::endl;
using std::string;
using abi::__cxa_demangle; // gcc 编译器中 完整输出类型

// class template
/**
* 当类模板碰到继承时，需要注意一下几点：
* 当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型
* 如果不指定，编译器无法给子类分配内存
* 如果想灵活指定出父类中T的类型，子类也需变为类模板
*/
template<typename T>
class Father{
    T n_Age;
};

// 1. 子类继承父类, 父类为class template 可以声明类型, 来分配内存
class SonA: public Father<int>{

};
void test01(){
    SonA s1;
};

// 2. 子类继承父类 如果想灵活指定出父类中T的类型，子类也需变为类模板
template<typename T,typename K>
class SonB:public Father<T>{
public:
    SonB(){
        cout<<"T的类型是: "<<__cxa_demangle(typeid(T).name(),0,0,0)<<endl;
        // T的类型是: std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >
        cout<<"K的类型是: "<<__cxa_demangle(typeid(K).name(),0,0,0)<<endl;
        //K的类型是: int
    };
};
void test02(){
    SonB<string,int>sb;
};
int main() {
    test01();
    test02();
    system("pause");
    return 0;
}
```

总结：如果父类是类模板，子类需要指定出父类中T的数据类型



#### 1.3.6 类模板成员函数类外实现



学习目标：能够掌握类模板中的成员函数类外实现



**示例：**

```c++
// 类模板 成员函数 在 类外部的实现
template<typename T,typename K>
class Person{
public:
    T n_Name;
    K n_Age;
    Person(T name,K age);// 构造函数内部声明, 外部实现
    void showInfo(); // 普通成员类内声明, 外部实现
};

// 1. 构造函数的外部定义实现
template<typename T, typename K>
Person<T,K>::Person(T name,K age){
    this->n_Age=age;
    this->n_Name=name;
};

// 2. 普通函数的外部定义实现
template<typename T,typename K>
void Person<T,K>::showInfo() {
    cout<<"name is : "<<this->n_Name<<endl;
    cout<<"age is : "<<this->n_Age<<endl;
}

void test01(){
    Person<string ,int>p1("张三",22);
    p1.showInfo();
};
int main() {
    test01();
    system("pause");
    return 0;
}
```

总结：类模板中成员函数类外实现时，需要加上模板参数列表



#### 1.3.7 类模板分文件编写

学习目标：

* 掌握类模板成员函数分文件编写产生的问题以及解决方式



问题：

* 类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到


解决：

* 解决方式1：直接包含.cpp源文件
* 解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制



**示例：**

+ 正常编写示例:

  ```c++
  #include <iostream>
  using std::cout;
  using std::endl;
  using std::string;
  // 类模板的分文件编写
  
  // 原来的编写
  template<typename T,typename  K>
  class Person{
  public:
      T n_Name;
      K n_Age;
      Person(T name,K age);
      void showInfo();
  
  
  };
  // 1. 类外实现成员函数
  template <typename T,typename K>
  Person<T,K>::Person(T name,K age){
      this->n_Name=name;
      this->n_Age=age;
  };
  
  template <typename T,typename K>
  void Person<T, K>::showInfo() {
      cout<<"name is :"<<this->n_Name<<endl;
      cout<<"age is :"<<this->n_Age<<endl;
  };
  void test01(){
      Person<string,int>p1("张安",23);
      p1.showInfo();
  };
  // 2.导入class template时, 因为方法只会在调用时才会创建,所以不能直接导入.h声明文件
  // 第一种拆开方法, 将其拆开并引入cpp,而不是.h文件, 文件 Person.h, Person.cpp
  
  
  int main() {
      test01();
      system("pause");
      return 0;
  }
  ```

+ **类模板拆开需要引入 .cpp文件, 而不是仅用于声明的 .h头文件**:

  person.h

  ```c++
  #pragma once
  #include <iostream>
  using std::cout;
  using std::endl;
  using std::string;
  
  template<typename T,typename  K>
  class Person{
  public:
      T n_Name;
      K n_Age;
      Person(T name,K age);
      void showInfo();
  
  
  };
  ```

  

  person.cpp

  ```c++
  #include "014_person.h"
  // 1. 类外实现成员函数
  template <typename T,typename K>
  Person<T,K>::Person(T name,K age){
      this->n_Name=name;
      this->n_Age=age;
  };
  
  template <typename T,typename K>
  void Person<T, K>::showInfo() {
      cout<<"name is :"<<this->n_Name<<endl;
      cout<<"age is :"<<this->n_Age<<endl;
  };
  ```

  **或者直接引入 .hpp 文件, 所有逻辑都写在一起**

  person.hpp

  ```c++
  #pragma once
  #include <iostream>
  using std::cout;
  using std::endl;
  using std::string;
  
  template<typename T,typename  K>
  class Person{
  public:
      T n_Name;
      K n_Age;
      Person(T name,K age);
      void showInfo();
  
  
  };
  
  // 1. 类外实现成员函数
  template <typename T,typename K>
  Person<T,K>::Person(T name,K age){
      this->n_Name=name;
      this->n_Age=age;
  };
  
  template <typename T,typename K>
  void Person<T, K>::showInfo() {
      cout<<"name is :"<<this->n_Name<<endl;
      cout<<"age is :"<<this->n_Age<<endl;
  };
  ```

  main.cpp:

  ```c++
  #include <iostream>
  #include "016_subfile_person.hpp"
  // 或者
  // #include "014_person.cpp"
  
  using std::cout;
  using std::endl;
  using std::string;
  
  void test01(){
      Person<string,int>p1("张撒比22",32);
      p1.showInfo();
  };
  // 2.导入class template时, 因为方法只会在调用时才会创建,所以不能直接导入.h声明文件
  // 第一种拆开方法, 将其拆开并引入cpp,而不是.h文件, 文件 Person.h, Person.cpp
  
  
  int main() {
      test01();
      system("pause");
      return 0;
  }
  ```


​		总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp

#### 1.3.8 类模板与友元



学习目标：

* 掌握类模板配合友元函数的类内和类外实现



全局函数类内实现 - 直接在类内声明友元即可

全局函数类外实现 - 需要提前让编译器知道全局函数的存在



**示例：**

```c++
// class template 声明友元函数
// 1. 全局函数做友元函数, class 内实现
// 2. 全局函数做友元函数, class 外实现

// class 内外实现, 要先声明 class
template<typename T,typename K>
class Person;

template<typename T,typename K>
void printInfo(Person<T,K>& p){
    cout<<"name :"<<p.m_Name<<endl;
    cout<<"age :"<<p.m_Age<<endl;
}

template<typename T,typename K>
class Person{
    // 1.友元函数 class 内实现
    friend void showInfo(Person<T,K>* p){
        cout<<"name :"<<p->m_Name<<endl;
        cout<<"age :"<<p->m_Age<<endl;
    };
    friend void printInfo<>(Person<T,K>& p);
public:
    T m_Name;
    K m_Age;
    Person(T name,K age){
        this->m_Name=name;
        this->m_Age=age;
    };

};
// class 内实现
void test01(){
    Person<string,int>* p=new Person<string,int>("张三",34);
    showInfo(p);
};
// 2. class 外实现;
void test02(){
    Person<string,int>p("张天时",24);
    printInfo(p);
};

int main() {
    test01();
    test02();
    system("pause");
    return 0;
}
```

总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别





#### 1.3.9 类模板案例

案例描述:  实现一个通用的数组类，要求如下：



- 可以对内置数据类型以及自定义数据类型的数据进行存储
- 将数组中的数据存储到堆区
- 构造函数中可以传入数组的容量
- 提供对应的拷贝构造函数以及operator=防止浅拷贝问题
- 提供尾插法和尾删法对数组中的数据进行增加和删除
- 可以通过下标的方式访问数组中的元素
- 可以获取数组中当前元素个数和数组的容量





**示例：**

**main.cpp**

```c++
#include <iostream>
#include "019_myArray_class_template.hpp"
using std::cout;
using std::endl;
using std::string;

void test01(){
    MyArray<int>arr1(5);
    MyArray<int>arr2(arr1);
    MyArray<int>arr3(100);
    arr3=arr1;// operator overload func execute
};
void printArr(MyArray<int>& arr1){
    for (int i = 0; i < arr1.getLength(); ++i) {
            cout<<(arr1[i])<<endl;
    }
};

void test02(){
    MyArray<int>arr1(5);
    for (int i = 0; i < 5; ++i) {
        arr1.Push_Back(i);
    }
    printArr(arr1);
    cout<<"arr1的容量:"<<arr1.getCapacity()<<endl;// 5
    cout<<"arr1的大小:"<<arr1.getLength()<<endl;// 5
};

// 测试自定义数据类型
class Hero{
public:
    string m_Name;
    int m_Age;
    Hero(){};
    Hero(string name,int age){
        this->m_Name=name;
        this->m_Age=age;
    };
};
void printArr(MyArray<Hero>& arr){
    for (int i = 0; i < arr.getLength(); ++i) {
        cout<<"姓名:"<<arr[i].m_Name<<"  年龄:"<<arr[i].m_Age<<endl;
    }

};

void test03(){
    Hero h1("猴",114514);
    Hero h2("猪",110);
    Hero h3("鱼",1200);
    Hero h4("狗头",12000);
    Hero h5("牛头",9000);
    Hero h[5]={h1,h2,h3,h4,h5};

    MyArray<Hero>arr1(10);
    for (int i = 0; i < sizeof (h)/sizeof (h[0]); ++i) {
        arr1.Push_Back(h[i]);
    }
    printArr(arr1);
    cout<<"arr1的容量:"<<arr1.getCapacity()<<endl;// 10
    cout<<"arr1的大小:"<<arr1.getLength()<<endl;// 5

};
int main() {
//    test01();
//    test02();
    test03();
    system("pause");
    return 0;
}
```

**MyArr.hpp**

```c++
#pragma once
#include <iostream>


using std::cout;
using std::endl;
using std::string;

//- 可以对内置数据类型以及自定义数据类型的数据进行存储
//- 将数组中的数据存储到堆区
//- 构造函数中可以传入数组的容量
//- 提供对应的拷贝构造函数以及operator=防止浅拷贝问题
//- 提供尾插法和尾删法对数组中的数据进行增加和删除
//- 可以通过下标的方式访问数组中的元素
//- 可以获取数组中当前元素个数和数组的容量

template <typename T>
class MyArray{
public:
    // has params constructor func
    MyArray(int capacity){
        this->capacity=capacity;
        this->length=0;
        this->pArray=new T[this->capacity];
        cout<<"params constructor func execute"<<endl;
    };
    // copy constructor func
    MyArray(const MyArray& array){
        //+ 作用: 常量引用主要用来修饰形参, 防止误操作,引用的本质就是一个常量指针,即指针的指向不能被更改,
        // 加上const,即const MyArray* const pArray=要拷贝的实例
        //+ 在函数形参列表中, 可以加 <mark>const</mark>修饰符,防止形参改变实参
        this->capacity=array.capacity;
        this->length=array.length;
        this->pArray=new T[this->capacity];
        for (int i = 0; i < this->length; i++) {
            this->pArray[i]=array.pArray[i];
        }
        cout<<"copy constructor func execute"<<endl;
    }
    // operator overload 一定要使用引用作为函数返回值,不然相当于新建一个实例
    MyArray& operator=(const MyArray& array){
        if (this->pArray != NULL)
        {
            delete[] this->pArray;
            this->pArray = NULL;
            this->capacity = 0;
            this->length = 0;
        }
        this->capacity=array.capacity;
        this->length=array.length;
        this->pArray=new T[this->capacity];
        for (int i = 0; i < this->length; i++) {
            this->pArray[i]=pArray[i];
        }
        cout<<"operator = func execute"<<endl;
        return *this;// 对实例解引用
    }
    // destructor func
    ~ MyArray(){
        if (this->pArray != NULL)
        {
            delete[] this->pArray;
            this->pArray = NULL;
            this->capacity = 0;
            this->length = 0;
        }
        cout<<"destructor func execute"<<endl;
    };
    // 尾插函数
    void Push_Back(T& item){
        if(this->length==this->capacity){
            // 达到容量大小时,不再插入
            return;
        }
        this->pArray[this->length]=item;
        this->length++;
    };
    // 尾删函数, 删除数组最后一个元素,(让用户访问不到这个元素(软删除))
    void Pop_Back(){
        if(this->length==0){
            return;
        };
        this->length--;
    }
    // 中括号重载, 通过下标方式来访问数组重的数据
    T& operator[](int index){
        return this->pArray[index];
    };
    // 获取数组容量
    int getCapacity(){
        return  this->capacity;
    };
    // 获取数组长度
    int getLength(){
      return  this->length;
    };

private:
    T* pArray;// 数组类型的指针
    int capacity; // 容量
    int length;// 长度
};
```



## 2 STL初识

### 2.1 STL的诞生



* 长久以来，软件界一直希望建立一种可重复利用的东西

* C++的**面向对象**和**泛型编程**思想，目的就是**复用性的提升**

* 大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作

* 为了建立数据结构和算法的一套标准,诞生了**STL**

  


### 2.2 STL基本概念



* STL(Standard Template Library,**标准模板库**)
* STL 从广义上分为: **容器(container) 算法(algorithm) 迭代器(iterator)**
* **容器**和**算法**之间通过**迭代器**进行无缝连接。
* STL 几乎所有的代码都采用了模板类或者模板函数





### 2.3 STL六大组件

STL大体分为六大组件，分别是:**容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器**



1. 容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。
2. 算法：各种常用的算法，如sort、find、copy、for_each等
3. 迭代器：扮演了容器与算法之间的胶合剂。
4. 仿函数：行为类似函数，可作为算法的某种策略。
5. 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。
6. 空间配置器：负责空间的配置与管理。





### 2.4  STL中容器、算法、迭代器



**容器：**置物之所也

STL**容器**就是将运用**最广泛的一些数据结构**实现出来

常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等

这些容器分为**序列式容器**和**关联式容器**两种:

​	**序列式容器**:强调值的排序，序列式容器中的每个元素均有固定的位置。
​	**关联式容器**:二叉树结构，各元素之间没有严格的物理上的顺序关系



**算法：**问题之解法也

有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)

算法分为:**质变算法**和**非质变算法**。

质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等

非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等



**迭代器：**容器和算法之间粘合剂

提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。

每个容器都有自己专属的迭代器

迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针



迭代器种类：

| 种类           | 功能                                                     | 支持运算                                |
| -------------- | -------------------------------------------------------- | --------------------------------------- |
| 输入迭代器     | 对数据的只读访问                                         | 只读，支持++、==、！=                   |
| 输出迭代器     | 对数据的只写访问                                         | 只写，支持++                            |
| 前向迭代器     | 读写操作，并能向前推进迭代器                             | 读写，支持++、==、！=                   |
| 双向迭代器     | 读写操作，并能向前和向后操作                             | 读写，支持++、--，                      |
| 随机访问迭代器 | 读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器 | 读写，支持++、--、[n]、-n、<、<=、>、>= |

常用的容器中迭代器种类为双向迭代器，和随机访问迭代器





### 2.5 容器算法迭代器初识



了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力

STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器



#### 2.5.1 vector存放内置数据类型



容器：     `vector`

算法：     `for_each`

迭代器： `vector<int>::iterator`

把迭代器理解为一个指针

**示例：**

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using std::cout;
using std::endl;
using std::string;
using std::vector;

template<typename T>
void printItem(T val){
    cout<<val<<endl;
    cout<<"execute"<<endl;
}

void test01(){
    //创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型
    vector<int>v;
    int a[5]={10,20,30,40,50};
    for (int i = 0; i < sizeof (a)/sizeof a[0]; ++i) {
        // 向容器中push 数据
        v.push_back(a[i]);
    }
    //每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素
    // 把迭代器看成一个指针
    //v.begin()返回迭代器，这个迭代器指向容器中第一个数据
    //v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置
    //vector<int>::iterator 拿到vector<int>这种容器的迭代器类型
    vector<int>::iterator pBegin=v.begin();
    vector<int>::iterator pEnd=v.end();

    // 遍历数据
    // 1. 第一种方式, 手动遍历迭代器
    while(pBegin!=pEnd){
        cout<<*pBegin<<endl;
        pBegin++;
    }

    // 2. 使用for循环
    for (vector<int>::iterator it=v.begin();it!=v.end();it++) {
        cout<<*it<<endl;
    }

    // 3. 使用 algorithm 提供的算法来进行遍历
    std::for_each(v.begin(),v.end(),printItem<int>);
};

int main() {
    test01();
    system("pause");
    return 0;
}
```

#### 2.5.2 Vector存放自定义数据类型



学习目标：vector中存放自定义数据类型，并打印输出



**示例：**

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using std::cout;
using std::endl;
using std::string;
using std::vector;

class Hero{
public:
    Hero(string name,int age){
        this->m_Name=name;
        this->m_Age=age;
    };
    string m_Name;
    int m_Age;
};

void printItem(Hero h){
    cout<<"姓名: "<<h.m_Name<<"年龄:"<<h.m_Age<<endl;
}

void test01(){
    //创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型
    Hero h1("孙悟空",2200);
    Hero h2("唐僧",40);
    Hero h3("赵云",33);
    Hero h4("钟繇",45);
    Hero h5("贾宝玉",22);
    vector<Hero>v;
    Hero a[5]={h1,h2,h3,h4,h5};
    for (int i = 0; i < sizeof (a)/sizeof a[0]; ++i) {
        // 向容器中push 数据
        v.push_back(a[i]);
    }
    //每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素
    // 把迭代器看成一个指针
    //v.begin()返回迭代器，这个迭代器指向容器中第一个数据
    //v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置
    //vector<int>::iterator 拿到vector<int>这种容器的迭代器类型
    vector<Hero>::iterator pBegin=v.begin();
    vector<Hero>::iterator pEnd=v.end();

    // 遍历数据
    // 1. 第一种方式, 手动遍历迭代器
    while(pBegin!=pEnd){
        printItem(*pBegin);
        pBegin++;
    }

    // 2. 使用for循环
    for (vector<Hero>::iterator it=v.begin();it!=v.end();it++) {
        printItem(*it);
    }

    // 3. 使用 algorithm 提供的算法来进行遍历
    std::for_each(v.begin(),v.end(),printItem);
};

int main() {
    test01();
    system("pause");
    return 0;
}
```

